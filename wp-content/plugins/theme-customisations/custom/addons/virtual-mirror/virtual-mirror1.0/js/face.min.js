import{FACES as indices,UVS as texCoords}from"./geometry.min.js";import{BufferGeometry,BufferAttribute,Vector3,Triangle,Matrix4}from"../core/ext_js/three/three.module.min.js";function getScale(t,s,e){var i=t.mesh[s],o=t.scaledMesh[s],r=t.mesh[e],h=t.scaledMesh[e],n=r[0]-i[0];return(h[0]-o[0])/n}class FaceMeshFaceGeometry extends BufferGeometry{constructor(t={}){super(),this.useVideoTexture=t.useVideoTexture||!1,this.normalizeCoords=t.normalizeCoords||!1,this.flipped=!1,this.positions=new Float32Array(1404),this.uvs=new Float32Array(936),this.setAttribute("position",new BufferAttribute(this.positions,3)),this.setAttribute("uv",new BufferAttribute(this.uvs,2)),this.setUvs(),this.setIndex(indices),this.computeVertexNormals(),this.applyMatrix4((new Matrix4).makeScale(10,10,10)),this.p0=new Vector3,this.p1=new Vector3,this.p2=new Vector3,this.face=null,this.triangle=new Triangle}setUvs(){for(let t=0;t<468;t++)this.uvs[2*t]=this.flipped?1-texCoords[t][0]:texCoords[t][0],this.uvs[2*t+1]=1-texCoords[t][1];this.getAttribute("uv").needsUpdate=!0}setVideoUvs(){let t=0;for(let s=0;s<936;s+=2)this.uvs[s]=this.flipped?this.positions[t]/this.w+.5:1-(this.positions[t]/this.w+.5),this.uvs[s+1]=this.positions[t+1]/this.h+.5,t+=3;this.getAttribute("uv").needsUpdate=!0}setSize(t,s){this.w=t,this.h=s}update(t,s){let e=0;this.face=t;for(const i of t.scaledMesh)this.positions[e]=s?i[0]+.5*this.w:i[0]-.5*this.w,this.positions[e+1]=this.h-i[1]-.5*this.h,this.positions[e+2]=-i[2],e+=3;if(this.useVideoTexture){if(this.setVideoUvs(),this.normalizeCoords){let s=0;const e=this.h/this.w,i=2*Math.sqrt(this.w/1e3);for(const o of t.scaledMesh)this.positions[s]=i*(o[0]/this.w+.5),this.positions[s+1]=i*(-o[1]/this.h+.5)*e,this.positions[s+2]=i*(-o[2]/500),s+=3}}else s!==this.flipped&&(this.flipped=s,this.setUvs());this.attributes.position.needsUpdate=!0,this.computeVertexNormals()}track(t,s,e){const i=this.positions;this.p0.set(i[3*t],i[3*t+1],i[3*t+2]),this.p1.set(i[3*s],i[3*s+1],i[3*s+2]),this.p2.set(i[3*e],i[3*e+1],i[3*e+2]),this.triangle.set(this.p0,this.p1,this.p2);const o=new Vector3;this.triangle.getMidpoint(o);const r=new Vector3;this.triangle.getNormal(r);const h=new Matrix4,n=this.p1.clone().sub(this.p2).normalize(),a=this.p1.clone().sub(this.p0).normalize(),p=(new Vector3).crossVectors(n,a),c=(new Vector3).crossVectors(n,p).normalize(),l=(new Vector3).crossVectors(n,c).normalize();return h.makeBasis(n,c,l),{position:o,normal:r,rotation:h,scale:getScale(this.face,s,e)}}}export{FaceMeshFaceGeometry};